[{"content":"Recently I was tasked with consuming data from websocket, analyse it and then send data to Prometheus. The theory is pretty straight forward: getting data from websocket API in a stream and analyse and take the data points and send it to prometheus for visulization. In this blog you will have all the steps and code needed to reporduce this flow. With this in mind, I decided using python to achieve all these.\nPart 1. Websocket VS Rest reminder Before we start, I would like to have a bit of revision on Websocket API and how it is different from REST API\nThe diagram I took from internet explains it quite well. In simple term, you interact with REST API with a request and response fashion wheraes in websocket there is a two way connection established during interaction lifecycle therefore you dont need to constantly send request to server for retrieving data. At the end of the interaction, the two way connection is close.\nPart 2. Consuming a websocket API You could easily find some publicly availabel websocket API, the one I used for this blog is from Binance, one of the platform used by coin traders. Though myself is not doing any coin trading nor receiving any sponsorship from them. They have very detailed API documentation on their Spot API.\nThe following code snippet can be used to connect to websocket API:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import json import websocket socket = \u0026#34;wss://stream.binance.com:9443/ws/bnbusdt@kline_1m\u0026#34; def on_open(ws): print(\u0026#34;Opened connection\u0026#34;) def on_message(ws, message): data = json.loads(message) print(data) def on_open(ws): print(\u0026#34;Opened connection\u0026#34;) def on_error(ws, error): print(error) ws = websocket.WebSocketApp( socket, on_open=on_open, on_message=on_message, on_error=on_error, on_close=on_close) ws.run_forever()   Quick explanation Line 4 defines the websocket url, the details of this endpoint can be found here. \u0026ldquo;/bnbusdt@kline_1m\u0026rdquo; means retrieving data from the kline stream for bnb vs usdt, what is so called a symbol, these are cyrypto coin terminologies which you can fine richer explanations else where.\nLine 6 to line 17 defines the callback function with minimal functionality when message is received from the server. More details can be found in websocket-client official documentation.\nLine 19 and 10 creates a websocket instance and start connection and run forever.\nRun the above python code will give you this console output:\n1 2 3 4 5  Opened connection {\u0026#34;e\u0026#34;: \u0026#34;kline\u0026#34;, \u0026#34;E\u0026#34;: 1647220248756, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;k\u0026#34;: {\u0026#34;t\u0026#34;: 1647220200000, \u0026#34;T\u0026#34;: 1647220259999, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;1m\u0026#34;, \u0026#34;f\u0026#34;: 527449288, \u0026#34;L\u0026#34;: 527449503, \u0026#34;o\u0026#34;: \u0026#34;364.60000000\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;364.30000000\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;364.60000000\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;364.20000000\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;458.54400000\u0026#34;, \u0026#34;n\u0026#34;: 216, \u0026#34;x\u0026#34;: False, \u0026#34;q\u0026#34;: \u0026#34;167076.68030000\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;183.99400000\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;67043.53500000\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;0\u0026#34;}} {\u0026#34;e\u0026#34;: \u0026#34;kline\u0026#34;, \u0026#34;E\u0026#34;: 1647220251279, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;k\u0026#34;: {\u0026#34;t\u0026#34;: 1647220200000, \u0026#34;T\u0026#34;: 1647220259999, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;1m\u0026#34;, \u0026#34;f\u0026#34;: 527449288, \u0026#34;L\u0026#34;: 527449507, \u0026#34;o\u0026#34;: \u0026#34;364.60000000\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;364.30000000\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;364.60000000\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;364.20000000\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;460.67000000\u0026#34;, \u0026#34;n\u0026#34;: 220, \u0026#34;x\u0026#34;: False, \u0026#34;q\u0026#34;: \u0026#34;167851.03680000\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;184.66700000\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;67288.70890000\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;0\u0026#34;}} {\u0026#34;e\u0026#34;: \u0026#34;kline\u0026#34;, \u0026#34;E\u0026#34;: 1647220253583, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;k\u0026#34;: {\u0026#34;t\u0026#34;: 1647220200000, \u0026#34;T\u0026#34;: 1647220259999, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;1m\u0026#34;, \u0026#34;f\u0026#34;: 527449288, \u0026#34;L\u0026#34;: 527449513, \u0026#34;o\u0026#34;: \u0026#34;364.60000000\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;364.20000000\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;364.60000000\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;364.20000000\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;461.78000000\u0026#34;, \u0026#34;n\u0026#34;: 226, \u0026#34;x\u0026#34;: False, \u0026#34;q\u0026#34;: \u0026#34;168255.38670000\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;185.54600000\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;67608.92860000\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;0\u0026#34;}} Connection closed   Futher explore the API Previous step works fine with a single symbol, what if in the websocket I need data from more symbol or even in any websockets ?? The websockert API kindly offers subscription mode, with which you can subscribe multiple symbols and get the data back within the same websocket connection. refer to the following code for this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import json import websocket socket = \u0026#34;wss://stream.binance.com:9443/ws\u0026#34; ws = websocket.create_connection(socket) ws.send(json.dumps({ \u0026#34;method\u0026#34;: \u0026#34;SUBSCRIBE\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;btcusdt@kline_1m\u0026#34;, \u0026#34;bnbusdt@kline_1m\u0026#34;, \u0026#34;ethusdt@kline_1m\u0026#34;, \u0026#34;dogeusdt@kline_1m\u0026#34;, \u0026#34;xrpusdt@kline_1m\u0026#34; ], \u0026#34;id\u0026#34;: 1 })) def on_message(message): data = json.loads(message) print(data) while True: result = ws.recv() on_message(result) ws.close()   Quick explanation Line 6-17 creates a websocket connection, the first action is to send a message to endpoint to subscribe to steams that are of interests. The playload of the subscription is like this:\n1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;method\u0026#34;: \u0026#34;SUBSCRIBE\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;btcusdt@kline_1m\u0026#34;, \u0026#34;bnbusdt@kline_1m\u0026#34;, \u0026#34;ethusdt@kline_1m\u0026#34;, \u0026#34;dogeusdt@kline_1m\u0026#34;, \u0026#34;xrpusdt@kline_1m\u0026#34; ], \u0026#34;id\u0026#34;: 1 }   According to the API doc, the response of the first ws.sent(payload) call is\n1 2 3 4  { \u0026#34;result\u0026#34;: null, \u0026#34;id\u0026#34;: 1 }   When we inspect the console output when running the above python code we also get the following which indicates we are NOT doing something crazy !\n1 2 3 4  {\u0026#34;result\u0026#34;: \u0026#34;None\u0026#34;, \u0026#34;id\u0026#34;: 1} {\u0026#34;e\u0026#34;: \u0026#34;kline\u0026#34;, \u0026#34;E\u0026#34;: 1647220380568, \u0026#34;s\u0026#34;: \u0026#34;XRPUSDT\u0026#34;, \u0026#34;k\u0026#34;: {\u0026#34;t\u0026#34;: 1647220320000, \u0026#34;T\u0026#34;: 1647220379999, \u0026#34;s\u0026#34;: \u0026#34;XRPUSDT\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;1m\u0026#34;, \u0026#34;f\u0026#34;: 429501724, \u0026#34;L\u0026#34;: 429501859, \u0026#34;o\u0026#34;: \u0026#34;0.75860000\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;0.75920000\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;0.75920000\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;0.75860000\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;81089.00000000\u0026#34;, \u0026#34;n\u0026#34;: 136, \u0026#34;x\u0026#34;: true, \u0026#34;q\u0026#34;: \u0026#34;61541.60570000\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;63081.00000000\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;47874.45210000\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;0\u0026#34;}} {\u0026#34;e\u0026#34;: \u0026#34;kline\u0026#34;, \u0026#34;E\u0026#34;: 1647220382238, \u0026#34;s\u0026#34;: \u0026#34;BTCUSDT\u0026#34;, \u0026#34;k\u0026#34;: {\u0026#34;t\u0026#34;: 1647220380000, \u0026#34;T\u0026#34;: 1647220439999, \u0026#34;s\u0026#34;: \u0026#34;BTCUSDT\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;1m\u0026#34;, \u0026#34;f\u0026#34;: 1291349545, \u0026#34;L\u0026#34;: 1291349561, \u0026#34;o\u0026#34;: \u0026#34;38183.79000000\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;38183.79000000\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;38183.80000000\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;38183.79000000\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;0.25519000\u0026#34;, \u0026#34;n\u0026#34;: 17, \u0026#34;x\u0026#34;: false, \u0026#34;q\u0026#34;: \u0026#34;9744.12173000\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;0.03599000\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;1374.23496200\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;0\u0026#34;}} {\u0026#34;e\u0026#34;: \u0026#34;kline\u0026#34;, \u0026#34;E\u0026#34;: 1647220382372, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;k\u0026#34;: {\u0026#34;t\u0026#34;: 1647220380000, \u0026#34;T\u0026#34;: 1647220439999, \u0026#34;s\u0026#34;: \u0026#34;BNBUSDT\u0026#34;, \u0026#34;i\u0026#34;: \u0026#34;1m\u0026#34;, \u0026#34;f\u0026#34;: 527450005, \u0026#34;L\u0026#34;: 527450009, \u0026#34;o\u0026#34;: \u0026#34;363.80000000\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;363.70000000\u0026#34;, \u0026#34;h\u0026#34;: \u0026#34;363.80000000\u0026#34;, \u0026#34;l\u0026#34;: \u0026#34;363.70000000\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;2.58200000\u0026#34;, \u0026#34;n\u0026#34;: 5, \u0026#34;x\u0026#34;: false, \u0026#34;q\u0026#34;: \u0026#34;939.30620000\u0026#34;, \u0026#34;V\u0026#34;: \u0026#34;2.32800000\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;846.92640000\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;0\u0026#34;}}   As you could see from the screenshot, the first response from the server is the acknowledgement of the subscription. The data following the acknowledgement is the data for the symbols(remember the crypto trading jargon?), and indead we are receiving data for all the symbols we have subscribed to !\nPart 3. Add prometheus-client and create metric endpiont To start with part, first we want to add prometheus client to our code so that we could see metric being sent.\nRecall the follow symbol data output from our previous step:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  { \u0026#34;e\u0026#34;: \u0026#34;kline\u0026#34;, // Event type  \u0026#34;E\u0026#34;: 123456789, // Event time  \u0026#34;s\u0026#34;: \u0026#34;BNBBTC\u0026#34;, // Symbol  \u0026#34;k\u0026#34;: { \u0026#34;t\u0026#34;: 123400000, // Kline start time  \u0026#34;T\u0026#34;: 123460000, // Kline close time  \u0026#34;s\u0026#34;: \u0026#34;BNBBTC\u0026#34;, // Symbol  \u0026#34;i\u0026#34;: \u0026#34;1m\u0026#34;, // Interval  \u0026#34;f\u0026#34;: 100, // First trade ID  \u0026#34;L\u0026#34;: 200, // Last trade ID  \u0026#34;o\u0026#34;: \u0026#34;0.0010\u0026#34;, // Open price  \u0026#34;c\u0026#34;: \u0026#34;0.0020\u0026#34;, // Close price  \u0026#34;h\u0026#34;: \u0026#34;0.0025\u0026#34;, // High price  \u0026#34;l\u0026#34;: \u0026#34;0.0015\u0026#34;, // Low price  \u0026#34;v\u0026#34;: \u0026#34;1000\u0026#34;, // Base asset volume  \u0026#34;n\u0026#34;: 100, // Number of trades  \u0026#34;x\u0026#34;: false, // Is this kline closed?  \u0026#34;q\u0026#34;: \u0026#34;1.0000\u0026#34;, // Quote asset volume  \u0026#34;V\u0026#34;: \u0026#34;500\u0026#34;, // Taker buy base asset volume  \u0026#34;Q\u0026#34;: \u0026#34;0.500\u0026#34;, // Taker buy quote asset volume  \u0026#34;B\u0026#34;: \u0026#34;123456\u0026#34; // Ignore  } }   With reference to the doc, for our case we are interested in \u0026ldquo;l\u0026rdquo; and \u0026ldquo;h\u0026rdquo; in the \u0026ldquo;k\u0026rdquo; property for the low price and high price. Obviously we are interested in the \u0026ldquo;s\u0026rdquo; property as well for the name of the symbol. Once we understand what we need to do with our data, now it time to update the callback function accordingly to do our \u0026ldquo;analysis\u0026rdquo;. Our analysis here is as simple as just reading some properties and this is not very important here as it is on the business side in the real world, our goal in this blog is to retrieve the data and send to Prometheus and we can just send some properties as if it is our \u0026ldquo;analysis\u0026rdquo;. So let\u0026quot;s go\n1 2 3 4 5 6  def on_message(message): data = json.loads(message) if \u0026#34;k\u0026#34; not in data: pass else: print(data[\u0026#34;s\u0026#34;], data[\u0026#34;k\u0026#34;][\u0026#34;l\u0026#34;], data[\u0026#34;k\u0026#34;][\u0026#34;h\u0026#34;])   Once call back function is updated we should see the following output that captures properties we are interested\n1 2 3 4 5 6  BTCUSDT 38155.15000000 38170.16000000 ETHUSDT 2534.36000000 2535.02000000 XRPUSDT 0.76010000 0.76040000 BNBUSDT 364.40000000 364.50000000 DOGEUSDT 0.11180000 0.11180000 BTCUSDT 38153.01000000 38170.16000000   Now lets start ingesting data to Prometheus using prometheus-client. Obviously we can spent our whole night trying to understand the nitty gritty of prometheus-client, but that is not the purpose right ? Our purpose here is to the things going end to end from websocket to prometheus. So let\u0026quot;s grab just what we need for this excercise !\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import json import websocket from prometheus_client import Gauge, start_http_server g = Gauge(\u0026#34;SymbolPrice\u0026#34;, \u0026#34;Symbol high and low price\u0026#34;, [\u0026#34;symbols\u0026#34;]) start_http_server(8000) def on_message(message): data = json.loads(message) if \u0026#34;k\u0026#34; not in data: pass else: print(data[\u0026#34;s\u0026#34;], data[\u0026#34;k\u0026#34;][\u0026#34;l\u0026#34;], data[\u0026#34;k\u0026#34;][\u0026#34;h\u0026#34;]) g.labels(f\u0026#34;{data[\u0026#34;s\u0026#34;]}-high\u0026#34;).set(data[\u0026#34;k\u0026#34;][\u0026#34;h\u0026#34;]) g.labels(f\u0026#34;{data[\u0026#34;s\u0026#34;]}-low\u0026#34;).set(data[\u0026#34;k\u0026#34;][\u0026#34;l\u0026#34;])   Quick explanation Line 5 create a Gauge object, a Guage is a type of metrics to record a value. Like mentioned before there are other types of metrics worth exploring, sounds like a place to spend our \u0026ldquo;tech time\u0026rdquo;.\nLine 6 create a Prometheus endpoint where you could see the metrics at http://localhost:8080.\nWhen you run python code with above updates, you could start the metrics endpoint from http://localhost:8080 and see the following output. When you refresh the page you should be able to see symbol high and low price being updated! yay ! 😀\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # HELP python_gc_objects_collected_total Objects collected during gc # TYPE python_gc_objects_collected_total counter python_gc_objects_collected_total{generation=\u0026#34;0\u0026#34;} 311.0 python_gc_objects_collected_total{generation=\u0026#34;1\u0026#34;} 71.0 python_gc_objects_collected_total{generation=\u0026#34;2\u0026#34;} 0.0 # HELP python_gc_objects_uncollectable_total Uncollectable object found during GC # TYPE python_gc_objects_uncollectable_total counter python_gc_objects_uncollectable_total{generation=\u0026#34;0\u0026#34;} 0.0 python_gc_objects_uncollectable_total{generation=\u0026#34;1\u0026#34;} 0.0 python_gc_objects_uncollectable_total{generation=\u0026#34;2\u0026#34;} 0.0 # HELP python_gc_collections_total Number of times this generation was collected # TYPE python_gc_collections_total counter python_gc_collections_total{generation=\u0026#34;0\u0026#34;} 41.0 python_gc_collections_total{generation=\u0026#34;1\u0026#34;} 3.0 python_gc_collections_total{generation=\u0026#34;2\u0026#34;} 0.0 # HELP python_info Python platform information # TYPE python_info gauge python_info{implementation=\u0026#34;CPython\u0026#34;,major=\u0026#34;3\u0026#34;,minor=\u0026#34;9\u0026#34;,patchlevel=\u0026#34;0\u0026#34;,version=\u0026#34;3.9.0\u0026#34;} 1.0 # HELP SymbolPrice Symbol high and low price # TYPE SymbolPrice gauge SymbolPrice{symbols=\u0026#34;BNBUSDT-high\u0026#34;} 363.2 SymbolPrice{symbols=\u0026#34;BNBUSDT-low\u0026#34;} 363.0 SymbolPrice{symbols=\u0026#34;XRPUSDT-high\u0026#34;} 0.7599 SymbolPrice{symbols=\u0026#34;XRPUSDT-low\u0026#34;} 0.7591 SymbolPrice{symbols=\u0026#34;ETHUSDT-high\u0026#34;} 2525.16 SymbolPrice{symbols=\u0026#34;ETHUSDT-low\u0026#34;} 2523.81 SymbolPrice{symbols=\u0026#34;BTCUSDT-high\u0026#34;} 37984.81 SymbolPrice{symbols=\u0026#34;BTCUSDT-low\u0026#34;} 37971.19 SymbolPrice{symbols=\u0026#34;DOGEUSDT-high\u0026#34;} 0.1113 SymbolPrice{symbols=\u0026#34;DOGEUSDT-low\u0026#34;} 0.1112   Obvioiusly you could run docker cmd for this, I have also got a docker-compose.yml here as well.\n1 2 3 4 5 6 7 8  version:\u0026#34;3.9\u0026#34;services:prometheus:image:prom/prometheusports:- \u0026#34;9090:9090\u0026#34;volumes:- /pathofown/prometheus.yml:/etc/prometheus/prometheus.yml  Before running this you will also need a prometheus configuration file with the name of \u0026ldquo;prometheus.yml\u0026rdquo;, in a nutshell in this file you will specify the metrics endpoint from where the server is going to collect data from. When running the Prometheus container, you need to mount the volume for you Prometheus container so that this config file is place in \u0026ldquo;/etc/prometheus/prometheus.yml\u0026rdquo; at container runtime.\n1 2 3 4 5 6 7 8 9 10 11  global:scrape_interval:5sevaluation_interval:5sscrape_configs:- job_name:\u0026#34;prome-local\u0026#34;static_configs:- targets:[\u0026#34;localhost:9090\u0026#34;]- job_name:\u0026#34;TestJob\u0026#34;static_configs:- targets:[\u0026#34;host.docker.internal:8000\u0026#34;]  Quick explanation Line 8 specifies the port of Prometheus server running locally Line 11 specifies the port and DNS name of the metric endpoint created in Part 3. Note the dns is \u0026ldquo;hosrt.docker.internal\u0026rdquo;, this worked for me when running containers with Docker Destop.\n Note the Prometheus server configuration could be way more complicated than what we are doing here.Again the purpose of this blog is not to setup prometheus for production, we only what to tip our teo on the surface and have a feel on it!  Lets start Docker Desktop and run Prometheus server locally either using docker cmd or docker-compose at choice of yours. When navigating to http://localhost:9090/targets，voilà ！Both the Prometheus server and the Metric endpoints for the websocekt are up and running !\nAs you can see both of the jobs that you specified in the prometheus.yml file are running !\nWhen navigate back to the graph page, you can easily enter \u0026ldquo;symbolPrice\u0026rdquo; in the search box and hit execute. You then should be able to see a graph like the following and you can highligh different lables to see the price change for each of the symbols. In may case I selected \u0026ldquo;BNBUSDT-high\u0026rdquo;\nCongratulations! You\u0026quot;v just reach the end of this blog, I know right ? It is a rather long blog to read, but at least I found the excercis pretty interesting and when you see the graph in Prometheus, it somewhat feeling really comforting !\nThanks for you patience, see you at my next blog !!\n","permalink":"https://blacklabnz.github.io/posts/websocket-prometheus/","summary":"Recently I was tasked with consuming data from websocket, analyse it and then send data to Prometheus. The theory is pretty straight forward: getting data from websocket API in a stream and analyse and take the data points and send it to prometheus for visulization. In this blog you will have all the steps and code needed to reporduce this flow. With this in mind, I decided using python to achieve all these.","title":"Consume Websocket stream and send to Prometheus in Python"},{"content":"Hi there, great to meet you here. My name is Neil，currently working as a Data Engineer operating in the cloud.\nPreviously I was working in DevOps capacity, focusing on building useful CICD pipelines, automations, APIs and else.\nThrough out my career, I\u0026rsquo;d like to share some tips and tricks which I hope you find helpful !\n","permalink":"https://blacklabnz.github.io/about/","summary":"Hi there, great to meet you here. My name is Neil，currently working as a Data Engineer operating in the cloud.\nPreviously I was working in DevOps capacity, focusing on building useful CICD pipelines, automations, APIs and else.\nThrough out my career, I\u0026rsquo;d like to share some tips and tricks which I hope you find helpful !","title":"About"}]