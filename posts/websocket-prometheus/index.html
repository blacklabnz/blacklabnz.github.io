<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Consume Websocket stream and send to Prometheus in Python | blacklabnz | Data | DevOps</title><meta name=keywords content="websocket,prometheus,python"><meta name=description content="Recently I was tasked with consuming data from websocket, analyze it and then send data to Prometheus. The theory is pretty straight forward: getting data from websocket API in a stream and analyze and take the data points and send it to prometheus for visualization. In this blog you will have all the steps and code needed to reproduce this flow. With this in mind, I decided using python to achieve all these."><meta name=author content="blacklabnz"><link rel=canonical href=https://blacklabnz.github.io/posts/websocket-prometheus/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.ed8304e9a7131d4ed812fbc7df21d2959f9ef0525fcc90f168c1e8f506768abc.css integrity="sha256-7YME6acTHU7YEvvH3yHSlZ+e8FJfzJDxaMHo9QZ2irw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blacklabnz.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blacklabnz.github.io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blacklabnz.github.io/favicon32x32.png><link rel=mask-icon href=https://blacklabnz.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin=anonymous><script async src="https://www.googletagmanager.com/gtag/js?id=G-FDV12HCDKK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FDV12HCDKK",{anonymize_ip:!1})}</script><meta property="og:title" content="Consume Websocket stream and send to Prometheus in Python"><meta property="og:description" content="Recently I was tasked with consuming data from websocket, analyze it and then send data to Prometheus. The theory is pretty straight forward: getting data from websocket API in a stream and analyze and take the data points and send it to prometheus for visualization. In this blog you will have all the steps and code needed to reproduce this flow. With this in mind, I decided using python to achieve all these."><meta property="og:type" content="article"><meta property="og:url" content="https://blacklabnz.github.io/posts/websocket-prometheus/"><meta property="og:image" content="https://blacklabnz.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-18T23:39:13+13:00"><meta property="article:modified_time" content="2022-03-20T00:00:00+00:00"><meta property="og:site_name" content="blacklabnz"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blacklabnz.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Consume Websocket stream and send to Prometheus in Python"><meta name=twitter:description content="Recently I was tasked with consuming data from websocket, analyze it and then send data to Prometheus. The theory is pretty straight forward: getting data from websocket API in a stream and analyze and take the data points and send it to prometheus for visualization. In this blog you will have all the steps and code needed to reproduce this flow. With this in mind, I decided using python to achieve all these."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blacklabnz.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Consume Websocket stream and send to Prometheus in Python","item":"https://blacklabnz.github.io/posts/websocket-prometheus/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Consume Websocket stream and send to Prometheus in Python","name":"Consume Websocket stream and send to Prometheus in Python","description":"Recently I was tasked with consuming data from websocket, analyze it and then send data to Prometheus. The theory is pretty straight forward: getting data from websocket API in a stream and analyze and take the data points and send it to prometheus for visualization. In this blog you will have all the steps and code needed to reproduce this flow. With this in mind, I decided using python to achieve all these.","keywords":["websocket","prometheus","python"],"articleBody":"Recently I was tasked with consuming data from websocket, analyze it and then send data to Prometheus. The theory is pretty straight forward: getting data from websocket API in a stream and analyze and take the data points and send it to prometheus for visualization. In this blog you will have all the steps and code needed to reproduce this flow. With this in mind, I decided using python to achieve all these.\nPart 1. Websocket VS Rest reminder Before we start, I would like to have a bit of revision on Websocket API and how it is different from REST API\nThe diagram I took from internet explains it quite well. In simple term, you interact with REST API with a request and response fashion whereas in websocket there is a two way connection established during interaction lifecycle therefore you don‚Äôt need to constantly send request to server for retrieving data. At the end of the interaction, the two way connection is close.\nPart 2. Consuming a websocket API You could easily find some publicly available websocket API, the one I used for this blog is from Binance, one of the platform used by coin traders. Though myself is not doing any coin trading nor receiving any sponsorship from them. They have very detailed API documentation on their Spot API.\nThe following code snippet can be used to connect to websocket API:\nimport json import websocket socket = \"wss://stream.binance.com:9443/ws/bnbusdt@kline_1m\" def on_open(ws): print(\"Opened connection\") def on_message(ws, message): data = json.loads(message) print(data) def on_open(ws): print(\"Opened connection\") def on_error(ws, error): print(error) ws = websocket.WebSocketApp( socket, on_open=on_open, on_message=on_message, on_error=on_error, on_close=on_close) ws.run_forever()  Quick explanation Line 4 defines the websocket url, the details of this endpoint can be found here. ‚Äú/bnbusdt@kline_1m‚Äù means retrieving data from the kline stream for bnb vs usdt, what is so called a symbol, these are crypto coin terminologies which you can fine richer explanations else where.\nLine 6 to line 17 defines the callback function with minimal functionality when message is received from the server. More details can be found in websocket-client official documentation.\nLine 19 and 10 creates a websocket instance and start connection and run forever.\nRun the above python code will give you this console output:\nOpened connection {\"e\": \"kline\", \"E\": 1647220248756, \"s\": \"BNBUSDT\", \"k\": {\"t\": 1647220200000, \"T\": 1647220259999, \"s\": \"BNBUSDT\", \"i\": \"1m\", \"f\": 527449288, \"L\": 527449503, \"o\": \"364.60000000\", \"c\": \"364.30000000\", \"h\": \"364.60000000\", \"l\": \"364.20000000\", \"v\": \"458.54400000\", \"n\": 216, \"x\": False, \"q\": \"167076.68030000\", \"V\": \"183.99400000\", \"Q\": \"67043.53500000\", \"B\": \"0\"}} {\"e\": \"kline\", \"E\": 1647220251279, \"s\": \"BNBUSDT\", \"k\": {\"t\": 1647220200000, \"T\": 1647220259999, \"s\": \"BNBUSDT\", \"i\": \"1m\", \"f\": 527449288, \"L\": 527449507, \"o\": \"364.60000000\", \"c\": \"364.30000000\", \"h\": \"364.60000000\", \"l\": \"364.20000000\", \"v\": \"460.67000000\", \"n\": 220, \"x\": False, \"q\": \"167851.03680000\", \"V\": \"184.66700000\", \"Q\": \"67288.70890000\", \"B\": \"0\"}} {\"e\": \"kline\", \"E\": 1647220253583, \"s\": \"BNBUSDT\", \"k\": {\"t\": 1647220200000, \"T\": 1647220259999, \"s\": \"BNBUSDT\", \"i\": \"1m\", \"f\": 527449288, \"L\": 527449513, \"o\": \"364.60000000\", \"c\": \"364.20000000\", \"h\": \"364.60000000\", \"l\": \"364.20000000\", \"v\": \"461.78000000\", \"n\": 226, \"x\": False, \"q\": \"168255.38670000\", \"V\": \"185.54600000\", \"Q\": \"67608.92860000\", \"B\": \"0\"}} Connection closed  Futher explore the API Previous step works fine with a single symbol, what if in the websocket I need data from more symbol or even in any websockets ?? The websocket API kindly offers subscription mode, with which you can subscribe multiple symbols and get the data back within the same websocket connection. refer to the following code for this:\nimport json import websocket socket = \"wss://stream.binance.com:9443/ws\" ws = websocket.create_connection(socket) ws.send(json.dumps({ \"method\": \"SUBSCRIBE\", \"params\": [ \"btcusdt@kline_1m\", \"bnbusdt@kline_1m\", \"ethusdt@kline_1m\", \"dogeusdt@kline_1m\", \"xrpusdt@kline_1m\" ], \"id\": 1 })) def on_message(message): data = json.loads(message) print(data) while True: result = ws.recv() on_message(result) ws.close()  Quick explanation Line 6-17 creates a websocket connection, the first action is to send a message to endpoint to subscribe to steams that are of interests. The payload of the subscription is like this:\n{ \"method\": \"SUBSCRIBE\", \"params\": [ \"btcusdt@kline_1m\", \"bnbusdt@kline_1m\", \"ethusdt@kline_1m\", \"dogeusdt@kline_1m\", \"xrpusdt@kline_1m\" ], \"id\": 1 }  According to the API doc, the response of the first ws.sent(payload) call is\n{ \"result\": null, \"id\": 1 }  When we inspect the console output when running the above python code we also get the following which indicates we are NOT doing something crazy !\n{\"result\": \"None\", \"id\": 1} {\"e\": \"kline\", \"E\": 1647220380568, \"s\": \"XRPUSDT\", \"k\": {\"t\": 1647220320000, \"T\": 1647220379999, \"s\": \"XRPUSDT\", \"i\": \"1m\", \"f\": 429501724, \"L\": 429501859, \"o\": \"0.75860000\", \"c\": \"0.75920000\", \"h\": \"0.75920000\", \"l\": \"0.75860000\", \"v\": \"81089.00000000\", \"n\": 136, \"x\": true, \"q\": \"61541.60570000\", \"V\": \"63081.00000000\", \"Q\": \"47874.45210000\", \"B\": \"0\"}} {\"e\": \"kline\", \"E\": 1647220382238, \"s\": \"BTCUSDT\", \"k\": {\"t\": 1647220380000, \"T\": 1647220439999, \"s\": \"BTCUSDT\", \"i\": \"1m\", \"f\": 1291349545, \"L\": 1291349561, \"o\": \"38183.79000000\", \"c\": \"38183.79000000\", \"h\": \"38183.80000000\", \"l\": \"38183.79000000\", \"v\": \"0.25519000\", \"n\": 17, \"x\": false, \"q\": \"9744.12173000\", \"V\": \"0.03599000\", \"Q\": \"1374.23496200\", \"B\": \"0\"}} {\"e\": \"kline\", \"E\": 1647220382372, \"s\": \"BNBUSDT\", \"k\": {\"t\": 1647220380000, \"T\": 1647220439999, \"s\": \"BNBUSDT\", \"i\": \"1m\", \"f\": 527450005, \"L\": 527450009, \"o\": \"363.80000000\", \"c\": \"363.70000000\", \"h\": \"363.80000000\", \"l\": \"363.70000000\", \"v\": \"2.58200000\", \"n\": 5, \"x\": false, \"q\": \"939.30620000\", \"V\": \"2.32800000\", \"Q\": \"846.92640000\", \"B\": \"0\"}}  As you could see from the screenshot, the first response from the server is the acknowledgement of the subscription. The data following the acknowledgement is the data for the symbols(remember the crypto trading jargon?), and indeed we are receiving data for all the symbols we have subscribed to !\nPart 3. Add prometheus-client and create metric endpoint To start with part, first we want to add prometheus client to our code so that we could see metric being sent.\nRecall the follow symbol data output from our previous step:\n{ \"e\": \"kline\", // Event type \"E\": 123456789, // Event time \"s\": \"BNBBTC\", // Symbol \"k\": { \"t\": 123400000, // Kline start time \"T\": 123460000, // Kline close time \"s\": \"BNBBTC\", // Symbol \"i\": \"1m\", // Interval \"f\": 100, // First trade ID \"L\": 200, // Last trade ID \"o\": \"0.0010\", // Open price \"c\": \"0.0020\", // Close price \"h\": \"0.0025\", // High price \"l\": \"0.0015\", // Low price \"v\": \"1000\", // Base asset volume \"n\": 100, // Number of trades \"x\": false, // Is this kline closed? \"q\": \"1.0000\", // Quote asset volume \"V\": \"500\", // Taker buy base asset volume \"Q\": \"0.500\", // Taker buy quote asset volume \"B\": \"123456\" // Ignore } }  With reference to the doc, for our case we are interested in ‚Äúl‚Äù and ‚Äúh‚Äù in the ‚Äúk‚Äù property for the low price and high price. Obviously we are interested in the ‚Äús‚Äù property as well for the name of the symbol. Once we understand what we need to do with our data, now it time to update the callback function accordingly to do our ‚Äúanalysis‚Äù. Our analysis here is as simple as just reading some properties and this is not very important here as it is on the business side in the real world, our goal in this blog is to retrieve the data and send to Prometheus and we can just send some properties as if it is our ‚Äúanalysis‚Äù. So let\"s go\ndef on_message(message): data = json.loads(message) if \"k\" not in data: pass else: print(data[\"s\"], data[\"k\"][\"l\"], data[\"k\"][\"h\"])  Once call back function is updated we should see the following output that captures properties we are interested\nBTCUSDT 38155.15000000 38170.16000000 ETHUSDT 2534.36000000 2535.02000000 XRPUSDT 0.76010000 0.76040000 BNBUSDT 364.40000000 364.50000000 DOGEUSDT 0.11180000 0.11180000 BTCUSDT 38153.01000000 38170.16000000  Now lets start ingesting data to Prometheus using prometheus-client. Obviously we can spent our whole night trying to understand the nitty gritty of prometheus-client, but that is not the purpose right ? Our purpose here is to the things going end to end from websocket to prometheus. So let\"s grab just what we need for this exercise !\nimport json import websocket from prometheus_client import Gauge, start_http_server g = Gauge(\"SymbolPrice\", \"Symbol high and low price\", [\"symbols\"]) start_http_server(8000) def on_message(message): data = json.loads(message) if \"k\" not in data: pass else: print(data[\"s\"], data[\"k\"][\"l\"], data[\"k\"][\"h\"]) g.labels(f\"{data[\"s\"]}-high\").set(data[\"k\"][\"h\"]) g.labels(f\"{data[\"s\"]}-low\").set(data[\"k\"][\"l\"])  Quick explanation Line 5 create a Gauge object, a Gauge is a type of metrics to record a value. Like mentioned before there are other types of metrics worth exploring, sounds like a place to spend our ‚Äútech time‚Äù.\nLine 6 create a Prometheus endpoint where you could see the metrics at http://localhost:8080.\nWhen you run python code with above updates, you could start the metrics endpoint from http://localhost:8080 and see the following output. When you refresh the page you should be able to see symbol high and low price being updated! yay ! üòÄ\n# HELP python_gc_objects_collected_total Objects collected during gc # TYPE python_gc_objects_collected_total counter python_gc_objects_collected_total{generation=\"0\"} 311.0 python_gc_objects_collected_total{generation=\"1\"} 71.0 python_gc_objects_collected_total{generation=\"2\"} 0.0 # HELP python_gc_objects_uncollectable_total Uncollectable object found during GC # TYPE python_gc_objects_uncollectable_total counter python_gc_objects_uncollectable_total{generation=\"0\"} 0.0 python_gc_objects_uncollectable_total{generation=\"1\"} 0.0 python_gc_objects_uncollectable_total{generation=\"2\"} 0.0 # HELP python_gc_collections_total Number of times this generation was collected # TYPE python_gc_collections_total counter python_gc_collections_total{generation=\"0\"} 41.0 python_gc_collections_total{generation=\"1\"} 3.0 python_gc_collections_total{generation=\"2\"} 0.0 # HELP python_info Python platform information # TYPE python_info gauge python_info{implementation=\"CPython\",major=\"3\",minor=\"9\",patchlevel=\"0\",version=\"3.9.0\"} 1.0 # HELP SymbolPrice Symbol high and low price # TYPE SymbolPrice gauge SymbolPrice{symbols=\"BNBUSDT-high\"} 363.2 SymbolPrice{symbols=\"BNBUSDT-low\"} 363.0 SymbolPrice{symbols=\"XRPUSDT-high\"} 0.7599 SymbolPrice{symbols=\"XRPUSDT-low\"} 0.7591 SymbolPrice{symbols=\"ETHUSDT-high\"} 2525.16 SymbolPrice{symbols=\"ETHUSDT-low\"} 2523.81 SymbolPrice{symbols=\"BTCUSDT-high\"} 37984.81 SymbolPrice{symbols=\"BTCUSDT-low\"} 37971.19 SymbolPrice{symbols=\"DOGEUSDT-high\"} 0.1113 SymbolPrice{symbols=\"DOGEUSDT-low\"} 0.1112  Part 4. Create Prometheus server and receive metrics data for visualization In this part you will need docker installed for creating Prometheus server in container. Please refer to official documentation for setup.\nObviously you could run docker cmd for this, I have also got a docker-compose.yml here as well.\nversion: \"3.9\" services: prometheus: image: prom/prometheus ports: - \"9090:9090\" volumes: - /pathofown/prometheus.yml:/etc/prometheus/prometheus.yml  Before running this you will also need a prometheus configuration file with the name of ‚Äúprometheus.yml‚Äù, in a nutshell in this file you will specify the metrics endpoint from where the server is going to collect data from. When running the Prometheus container, you need to mount the volume for you Prometheus container so that this config file is place in ‚Äú/etc/prometheus/prometheus.yml‚Äù at container runtime.\nglobal: scrape_interval: 5s evaluation_interval: 5s scrape_configs: - job_name: \"prome-local\" static_configs: - targets: [\"localhost:9090\"] - job_name: \"TestJob\" static_configs: - targets: [\"host.docker.internal:8000\"]  Quick explanation Line 8 specifies the port of Prometheus server running locally Line 11 specifies the port and DNS name of the metric endpoint created in Part 3. Note the dns is ‚Äúhost.docker.internal‚Äù, this worked for me when running containers with Docker Desktop.\n Note the Prometheus server configuration could be way more complicated than what we are doing here.Again the purpose of this blog is not to setup prometheus for production, we only what to tip our teo on the surface and have a feel on it!  Lets start Docker Desktop and run Prometheus server locally either using docker cmd or docker-compose at choice of yours. When navigating to http://localhost:9090/targetsÔºåvoil√† ÔºÅBoth the Prometheus server and the Metric endpoints for the websocket are up and running !\nAs you can see both of the jobs that you specified in the prometheus.yml file are running !\nWhen navigate back to the graph page, you can easily enter ‚ÄúsymbolPrice‚Äù in the search box and hit execute. You then should be able to see a graph like the following and you can highlight different labels to see the price change for each of the symbols. In may case I selected ‚ÄúBNBUSDT-high‚Äù\nCongratulations! You\"v just reach the end of this blog, I know right ? It is a rather long blog to read, but at least I found the exercise pretty interesting and when you see the graph in Prometheus, it somewhat feeling really comforting !\nThanks for you patience, see you at my next blog !!\n","wordCount":"1880","inLanguage":"en","datePublished":"2022-03-18T23:39:13+13:00","dateModified":"2022-03-20T00:00:00Z","author":{"@type":"Person","name":"blacklabnz"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blacklabnz.github.io/posts/websocket-prometheus/"},"publisher":{"@type":"Organization","name":"blacklabnz | Data | DevOps","logo":{"@type":"ImageObject","url":"https://blacklabnz.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><span class=header__inner><span class=logo><a href=https://blacklabnz.github.io/ accesskey=h title="blacklabnz (Alt + H)"><span><i class="fas fa-terminal fa-sm"></i></span>
<span class=logo_text>blacklabnz</span>
<span id=cursor></span></a></span>
<span class=header__right><div class=dropdown><span class=dropbtn><i class="fas fa-bars"></i></span><nav id=dropdonwBox class=dropdown-content><ul id=menu-mobile><li><a href=https://blacklabnz.github.io/posts title=blogs><span>blogs</span></a></li><li><a href=https://blacklabnz.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://blacklabnz.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://blacklabnz.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav><script src=/assets/js/menu.min.js></script></div><nav class=nav><ul id=menu><li><a href=https://blacklabnz.github.io/posts title=blogs><span>blogs</span></a></li><li><a href=https://blacklabnz.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://blacklabnz.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://blacklabnz.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav><ul class=logo-switches></ul><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></span></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blacklabnz.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://blacklabnz.github.io/posts/>Posts</a></div><h1 class=post-title>Consume Websocket stream and send to Prometheus in Python</h1><div class=post-meta><span title="2022-03-18 23:39:13 +1300 +1300">Created March 18, 2022</span>&nbsp;¬∑&nbsp;Updated Mar 20, 2022&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;blacklabnz&nbsp;|&nbsp;<a href=https://github.com/blacklabnz/blacklabnz.github.io/blob/main/content/posts/websocket-prometheus.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#part-1-websocket-vs-rest-reminder aria-label="Part 1. Websocket VS Rest reminder">Part 1. Websocket VS Rest reminder</a></li><li><a href=#part-2-consuming-a-websocket-api aria-label="Part 2. Consuming a websocket API">Part 2. Consuming a websocket API</a><ul><li><a href=#quick-explanation aria-label="Quick explanation">Quick explanation</a></li><li><a href=#futher-explore-the-api aria-label="Futher explore the API">Futher explore the API</a></li><li><a href=#quick-explanation-1 aria-label="Quick explanation">Quick explanation</a></li></ul></li><li><a href=#part-3-add-prometheus-client-and-create-metric-endpoint aria-label="Part 3. Add prometheus-client and create metric endpoint">Part 3. Add prometheus-client and create metric endpoint</a><ul><li><a href=#quick-explanation-2 aria-label="Quick explanation">Quick explanation</a></li></ul></li><li><a href=#part-4-create-prometheus-server-and-receive-metrics-data-for-visualization aria-label="Part 4. Create Prometheus server and receive metrics data for visualization">Part 4. Create Prometheus server and receive metrics data for visualization</a><ul><li><a href=#quick-explanation-3 aria-label="Quick explanation">Quick explanation</a></li></ul></li></ul></div></details></div><div class=post-content><p>Recently I was tasked with consuming data from websocket, analyze it and then send data to Prometheus.
The theory is pretty straight forward: getting data from websocket API in a stream and analyze and take the data points and send it to prometheus for visualization.
In this blog you will have all the steps and code needed to reproduce this flow.
With this in mind, I decided using python to achieve all these.</p><h2 id=part-1-websocket-vs-rest-reminder>Part 1. Websocket VS Rest reminder<a hidden class=anchor aria-hidden=true href=#part-1-websocket-vs-rest-reminder>#</a></h2><p>Before we start, I would like to have a bit of revision on Websocket API and how it is different from REST API</p><p><img loading=lazy src=/posts/websocket-prometheus/websocketvsrest.png alt=websocketvsrest></p><p>The diagram I took from internet explains it quite well. In simple term, you interact with REST API with a request and response fashion whereas in websocket there is a two way connection established during interaction lifecycle therefore you don&rsquo;t need to constantly send request to server for retrieving data. At the end of the interaction, the two way connection is close.</p><h2 id=part-2-consuming-a-websocket-api>Part 2. Consuming a websocket API<a hidden class=anchor aria-hidden=true href=#part-2-consuming-a-websocket-api>#</a></h2><p>You could easily find some publicly available websocket API, the one I used for this blog is from Binance, one of the platform used by coin traders. Though myself is not doing any coin trading nor receiving any sponsorship from them.
They have very detailed API documentation on their <a href=https://github.com/binance/binance-spot-api-docs>Spot API</a>.</p><p>The following code snippet can be used to connect to websocket API:</p><pre><code class=language-python>import json
import websocket

socket = &quot;wss://stream.binance.com:9443/ws/bnbusdt@kline_1m&quot;

def on_open(ws):
    print(&quot;Opened connection&quot;)

def on_message(ws, message):
    data = json.loads(message)
    print(data)

def on_open(ws):
    print(&quot;Opened connection&quot;)

def on_error(ws, error):
    print(error)

ws = websocket.WebSocketApp(
    socket, 
    on_open=on_open, 
    on_message=on_message, 
    on_error=on_error, 
    on_close=on_close)
    
ws.run_forever()
</code></pre><h3 id=quick-explanation>Quick explanation<a hidden class=anchor aria-hidden=true href=#quick-explanation>#</a></h3><p>Line 4 defines the websocket url, the details of this endpoint can be found <a href=https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md#klinecandlestick-streams>here</a>.
&ldquo;/bnbusdt@kline_1m&rdquo; means retrieving data from the kline stream for bnb vs usdt, what is so called a symbol, these are crypto coin terminologies which you can fine richer explanations else where.</p><p>Line 6 to line 17 defines the callback function with minimal functionality when message is received from the server.
More details can be found in <a href=https://websocket-client.readthedocs.io/en/latest/>websocket-client</a> official documentation.</p><p>Line 19 and 10 creates a websocket instance and start connection and run forever.</p><p>Run the above python code will give you this console output:</p><pre><code class=language-python>Opened connection
{&quot;e&quot;: &quot;kline&quot;, &quot;E&quot;: 1647220248756, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;k&quot;: {&quot;t&quot;: 1647220200000, &quot;T&quot;: 1647220259999, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;i&quot;: &quot;1m&quot;, &quot;f&quot;: 527449288, &quot;L&quot;: 527449503, &quot;o&quot;: &quot;364.60000000&quot;, &quot;c&quot;: &quot;364.30000000&quot;, &quot;h&quot;: &quot;364.60000000&quot;, &quot;l&quot;: &quot;364.20000000&quot;, &quot;v&quot;: &quot;458.54400000&quot;, &quot;n&quot;: 216, &quot;x&quot;: False, &quot;q&quot;: &quot;167076.68030000&quot;, &quot;V&quot;: &quot;183.99400000&quot;, &quot;Q&quot;: &quot;67043.53500000&quot;, &quot;B&quot;: &quot;0&quot;}}
{&quot;e&quot;: &quot;kline&quot;, &quot;E&quot;: 1647220251279, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;k&quot;: {&quot;t&quot;: 1647220200000, &quot;T&quot;: 1647220259999, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;i&quot;: &quot;1m&quot;, &quot;f&quot;: 527449288, &quot;L&quot;: 527449507, &quot;o&quot;: &quot;364.60000000&quot;, &quot;c&quot;: &quot;364.30000000&quot;, &quot;h&quot;: &quot;364.60000000&quot;, &quot;l&quot;: &quot;364.20000000&quot;, &quot;v&quot;: &quot;460.67000000&quot;, &quot;n&quot;: 220, &quot;x&quot;: False, &quot;q&quot;: &quot;167851.03680000&quot;, &quot;V&quot;: &quot;184.66700000&quot;, &quot;Q&quot;: &quot;67288.70890000&quot;, &quot;B&quot;: &quot;0&quot;}}
{&quot;e&quot;: &quot;kline&quot;, &quot;E&quot;: 1647220253583, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;k&quot;: {&quot;t&quot;: 1647220200000, &quot;T&quot;: 1647220259999, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;i&quot;: &quot;1m&quot;, &quot;f&quot;: 527449288, &quot;L&quot;: 527449513, &quot;o&quot;: &quot;364.60000000&quot;, &quot;c&quot;: &quot;364.20000000&quot;, &quot;h&quot;: &quot;364.60000000&quot;, &quot;l&quot;: &quot;364.20000000&quot;, &quot;v&quot;: &quot;461.78000000&quot;, &quot;n&quot;: 226, &quot;x&quot;: False, &quot;q&quot;: &quot;168255.38670000&quot;, &quot;V&quot;: &quot;185.54600000&quot;, &quot;Q&quot;: &quot;67608.92860000&quot;, &quot;B&quot;: &quot;0&quot;}}
Connection closed
</code></pre><h3 id=futher-explore-the-api>Futher explore the API<a hidden class=anchor aria-hidden=true href=#futher-explore-the-api>#</a></h3><p>Previous step works fine with a single symbol, what if in the websocket I need data from more symbol or even in any websockets ??
The websocket API kindly offers subscription mode, with which you can subscribe multiple symbols and get the data back within the same websocket connection. refer to the following code for this:</p><pre><code class=language-python>import json
import websocket

socket = &quot;wss://stream.binance.com:9443/ws&quot;

ws = websocket.create_connection(socket)
ws.send(json.dumps({
    &quot;method&quot;: &quot;SUBSCRIBE&quot;,
    &quot;params&quot;: [
        &quot;btcusdt@kline_1m&quot;,
        &quot;bnbusdt@kline_1m&quot;,
        &quot;ethusdt@kline_1m&quot;,
        &quot;dogeusdt@kline_1m&quot;,
        &quot;xrpusdt@kline_1m&quot;
    ],
    &quot;id&quot;: 1
}))

def on_message(message):
    data = json.loads(message)
    print(data)

while True:
    result = ws.recv()
    on_message(result)

ws.close()
</code></pre><h3 id=quick-explanation-1>Quick explanation<a hidden class=anchor aria-hidden=true href=#quick-explanation-1>#</a></h3><p>Line 6-17 creates a websocket connection, the first action is to send a message to endpoint to subscribe to steams that are of interests.
The payload of the subscription is like this:</p><pre><code class=language-json>{
    &quot;method&quot;: &quot;SUBSCRIBE&quot;,
    &quot;params&quot;: [
        &quot;btcusdt@kline_1m&quot;,
        &quot;bnbusdt@kline_1m&quot;,
        &quot;ethusdt@kline_1m&quot;,
        &quot;dogeusdt@kline_1m&quot;,
        &quot;xrpusdt@kline_1m&quot;
    ],
    &quot;id&quot;: 1
}
</code></pre><p>According to the <a href=https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md#live-subscribingunsubscribing-to-streams>API doc</a>, the response of the first ws.sent(payload) call is</p><pre><code class=language-json>{
    &quot;result&quot;: null,
    &quot;id&quot;: 1
}
</code></pre><p>When we inspect the console output when running the above python code we also get the following which indicates we are NOT doing something crazy !</p><pre><code class=language-json>{&quot;result&quot;: &quot;None&quot;, &quot;id&quot;: 1}
{&quot;e&quot;: &quot;kline&quot;, &quot;E&quot;: 1647220380568, &quot;s&quot;: &quot;XRPUSDT&quot;, &quot;k&quot;: {&quot;t&quot;: 1647220320000, &quot;T&quot;: 1647220379999, &quot;s&quot;: &quot;XRPUSDT&quot;, &quot;i&quot;: &quot;1m&quot;, &quot;f&quot;: 429501724, &quot;L&quot;: 429501859, &quot;o&quot;: &quot;0.75860000&quot;, &quot;c&quot;: &quot;0.75920000&quot;, &quot;h&quot;: &quot;0.75920000&quot;, &quot;l&quot;: &quot;0.75860000&quot;, &quot;v&quot;: &quot;81089.00000000&quot;, &quot;n&quot;: 136, &quot;x&quot;: true, &quot;q&quot;: &quot;61541.60570000&quot;, &quot;V&quot;: &quot;63081.00000000&quot;, &quot;Q&quot;: &quot;47874.45210000&quot;, &quot;B&quot;: &quot;0&quot;}}
{&quot;e&quot;: &quot;kline&quot;, &quot;E&quot;: 1647220382238, &quot;s&quot;: &quot;BTCUSDT&quot;, &quot;k&quot;: {&quot;t&quot;: 1647220380000, &quot;T&quot;: 1647220439999, &quot;s&quot;: &quot;BTCUSDT&quot;, &quot;i&quot;: &quot;1m&quot;, &quot;f&quot;: 1291349545, &quot;L&quot;: 1291349561, &quot;o&quot;: &quot;38183.79000000&quot;, &quot;c&quot;: &quot;38183.79000000&quot;, &quot;h&quot;: &quot;38183.80000000&quot;, &quot;l&quot;: &quot;38183.79000000&quot;, &quot;v&quot;: &quot;0.25519000&quot;, &quot;n&quot;: 17, &quot;x&quot;: false, &quot;q&quot;: &quot;9744.12173000&quot;, &quot;V&quot;: &quot;0.03599000&quot;, &quot;Q&quot;: &quot;1374.23496200&quot;, &quot;B&quot;: &quot;0&quot;}}
{&quot;e&quot;: &quot;kline&quot;, &quot;E&quot;: 1647220382372, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;k&quot;: {&quot;t&quot;: 1647220380000, &quot;T&quot;: 1647220439999, &quot;s&quot;: &quot;BNBUSDT&quot;, &quot;i&quot;: &quot;1m&quot;, &quot;f&quot;: 527450005, &quot;L&quot;: 527450009, &quot;o&quot;: &quot;363.80000000&quot;, &quot;c&quot;: &quot;363.70000000&quot;, &quot;h&quot;: &quot;363.80000000&quot;, &quot;l&quot;: &quot;363.70000000&quot;, &quot;v&quot;: &quot;2.58200000&quot;, &quot;n&quot;: 5, &quot;x&quot;: false, &quot;q&quot;: &quot;939.30620000&quot;, &quot;V&quot;: &quot;2.32800000&quot;, &quot;Q&quot;: &quot;846.92640000&quot;, &quot;B&quot;: &quot;0&quot;}}
</code></pre><p>As you could see from the screenshot, the first response from the server is the acknowledgement of the subscription.
The data following the acknowledgement is the data for the symbols(remember the crypto trading jargon?), and indeed we are receiving data for all the symbols we have subscribed to !</p><h2 id=part-3-add-prometheus-client-and-create-metric-endpoint>Part 3. Add prometheus-client and create metric endpoint<a hidden class=anchor aria-hidden=true href=#part-3-add-prometheus-client-and-create-metric-endpoint>#</a></h2><p>To start with part, first we want to add prometheus client to our code so that we could see metric being sent.</p><p>Recall the follow symbol data output from our previous step:</p><pre><code class=language-json>{
    &quot;e&quot;: &quot;kline&quot;,     // Event type
    &quot;E&quot;: 123456789,   // Event time
    &quot;s&quot;: &quot;BNBBTC&quot;,    // Symbol
    &quot;k&quot;: {
        &quot;t&quot;: 123400000, // Kline start time
        &quot;T&quot;: 123460000, // Kline close time
        &quot;s&quot;: &quot;BNBBTC&quot;,  // Symbol
        &quot;i&quot;: &quot;1m&quot;,      // Interval
        &quot;f&quot;: 100,       // First trade ID
        &quot;L&quot;: 200,       // Last trade ID
        &quot;o&quot;: &quot;0.0010&quot;,  // Open price
        &quot;c&quot;: &quot;0.0020&quot;,  // Close price
        &quot;h&quot;: &quot;0.0025&quot;,  // High price
        &quot;l&quot;: &quot;0.0015&quot;,  // Low price
        &quot;v&quot;: &quot;1000&quot;,    // Base asset volume
        &quot;n&quot;: 100,       // Number of trades
        &quot;x&quot;: false,     // Is this kline closed?
        &quot;q&quot;: &quot;1.0000&quot;,  // Quote asset volume
        &quot;V&quot;: &quot;500&quot;,     // Taker buy base asset volume
        &quot;Q&quot;: &quot;0.500&quot;,   // Taker buy quote asset volume
        &quot;B&quot;: &quot;123456&quot;   // Ignore
    }
}
</code></pre><p>With reference to the <a href=https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md#klinecandlestick-streams>doc</a>, for our case we are interested in &ldquo;l&rdquo; and &ldquo;h&rdquo; in the &ldquo;k&rdquo; property for the low price and high price. Obviously we are interested in the &ldquo;s&rdquo; property as well for the name of the symbol.
Once we understand what we need to do with our data, now it time to update the callback function accordingly to do our &ldquo;analysis&rdquo;.
Our analysis here is as simple as just reading some properties and this is not very important here as it is on the business side in the real world, our goal in this blog is to retrieve the data and send to Prometheus and we can just send some properties as if it is our &ldquo;analysis&rdquo;. So let"s go</p><pre><code class=language-python>def on_message(message):
    data = json.loads(message)
    if &quot;k&quot; not in data:
        pass
    else:
        print(data[&quot;s&quot;], data[&quot;k&quot;][&quot;l&quot;], data[&quot;k&quot;][&quot;h&quot;])
</code></pre><p>Once call back function is updated we should see the following output that captures properties we are interested</p><pre><code class=language-python>BTCUSDT 38155.15000000 38170.16000000
ETHUSDT 2534.36000000 2535.02000000
XRPUSDT 0.76010000 0.76040000
BNBUSDT 364.40000000 364.50000000
DOGEUSDT 0.11180000 0.11180000
BTCUSDT 38153.01000000 38170.16000000
</code></pre><p>Now lets start ingesting data to Prometheus using <a href=https://pypi.org/project/prometheus-client>prometheus-client</a>.
Obviously we can spent our whole night trying to understand the nitty gritty of prometheus-client, but that is not the purpose right ? Our purpose here is to the things going end to end from websocket to prometheus. So let"s grab just what we need for this exercise !</p><pre><code class=language-python>import json
import websocket
from prometheus_client import Gauge, start_http_server

g = Gauge(&quot;SymbolPrice&quot;, &quot;Symbol high and low price&quot;, [&quot;symbols&quot;])

start_http_server(8000)

def on_message(message):
    data = json.loads(message)
    if &quot;k&quot; not in data:
        pass
    else:
        print(data[&quot;s&quot;], data[&quot;k&quot;][&quot;l&quot;], data[&quot;k&quot;][&quot;h&quot;])
        g.labels(f&quot;{data[&quot;s&quot;]}-high&quot;).set(data[&quot;k&quot;][&quot;h&quot;])
        g.labels(f&quot;{data[&quot;s&quot;]}-low&quot;).set(data[&quot;k&quot;][&quot;l&quot;])
</code></pre><h3 id=quick-explanation-2>Quick explanation<a hidden class=anchor aria-hidden=true href=#quick-explanation-2>#</a></h3><p>Line 5 create a Gauge object, a Gauge is a type of metrics to record a value. Like mentioned before there are other types of metrics worth exploring, sounds like a place to spend our &ldquo;tech time&rdquo;.</p><p>Line 6 create a Prometheus endpoint where you could see the metrics at http://localhost:8080.</p><p>When you run python code with above updates, you could start the metrics endpoint from http://localhost:8080 and see the following output. When you refresh the page you should be able to see symbol high and low price being updated!
yay ! üòÄ</p><pre><code class=language-bash># HELP python_gc_objects_collected_total Objects collected during gc
# TYPE python_gc_objects_collected_total counter
python_gc_objects_collected_total{generation=&quot;0&quot;} 311.0
python_gc_objects_collected_total{generation=&quot;1&quot;} 71.0
python_gc_objects_collected_total{generation=&quot;2&quot;} 0.0
# HELP python_gc_objects_uncollectable_total Uncollectable object found during GC
# TYPE python_gc_objects_uncollectable_total counter
python_gc_objects_uncollectable_total{generation=&quot;0&quot;} 0.0
python_gc_objects_uncollectable_total{generation=&quot;1&quot;} 0.0
python_gc_objects_uncollectable_total{generation=&quot;2&quot;} 0.0
# HELP python_gc_collections_total Number of times this generation was collected
# TYPE python_gc_collections_total counter
python_gc_collections_total{generation=&quot;0&quot;} 41.0
python_gc_collections_total{generation=&quot;1&quot;} 3.0
python_gc_collections_total{generation=&quot;2&quot;} 0.0
# HELP python_info Python platform information
# TYPE python_info gauge
python_info{implementation=&quot;CPython&quot;,major=&quot;3&quot;,minor=&quot;9&quot;,patchlevel=&quot;0&quot;,version=&quot;3.9.0&quot;} 1.0
# HELP SymbolPrice Symbol high and low price
# TYPE SymbolPrice gauge
SymbolPrice{symbols=&quot;BNBUSDT-high&quot;} 363.2
SymbolPrice{symbols=&quot;BNBUSDT-low&quot;} 363.0
SymbolPrice{symbols=&quot;XRPUSDT-high&quot;} 0.7599
SymbolPrice{symbols=&quot;XRPUSDT-low&quot;} 0.7591
SymbolPrice{symbols=&quot;ETHUSDT-high&quot;} 2525.16
SymbolPrice{symbols=&quot;ETHUSDT-low&quot;} 2523.81
SymbolPrice{symbols=&quot;BTCUSDT-high&quot;} 37984.81
SymbolPrice{symbols=&quot;BTCUSDT-low&quot;} 37971.19
SymbolPrice{symbols=&quot;DOGEUSDT-high&quot;} 0.1113
SymbolPrice{symbols=&quot;DOGEUSDT-low&quot;} 0.1112
</code></pre><h2 id=part-4-create-prometheus-server-and-receive-metrics-data-for-visualization>Part 4. Create Prometheus server and receive metrics data for visualization<a hidden class=anchor aria-hidden=true href=#part-4-create-prometheus-server-and-receive-metrics-data-for-visualization>#</a></h2><p>In this part you will need docker installed for creating Prometheus server in container. Please refer to official <a href=https://prometheus.io/docs/prometheus/latest/installation/>documentation</a> for setup.</p><p>Obviously you could run docker cmd for this, I have also got a docker-compose.yml here as well.</p><pre><code class=language-yml>version: &quot;3.9&quot;
services:
  prometheus:
    image: prom/prometheus
    ports:
      - &quot;9090:9090&quot;
    volumes:
      - /pathofown/prometheus.yml:/etc/prometheus/prometheus.yml
</code></pre><p>Before running this you will also need a prometheus configuration file with the name of &ldquo;prometheus.yml&rdquo;, in a nutshell in this file you will specify the metrics endpoint from where the server is going to collect data from. When running the Prometheus container, you need to mount the <a href=https://docs.docker.com/storage/volumes/>volume</a> for you Prometheus container so that this config file is place in &ldquo;/etc/prometheus/prometheus.yml&rdquo; at container runtime.</p><pre><code class=language-yml>global:
  scrape_interval:     5s
  evaluation_interval: 5s

scrape_configs:
  - job_name: &quot;prome-local&quot;
    static_configs:
      - targets: [&quot;localhost:9090&quot;]
  - job_name: &quot;TestJob&quot;
    static_configs:
      - targets: [&quot;host.docker.internal:8000&quot;]
</code></pre><h3 id=quick-explanation-3>Quick explanation<a hidden class=anchor aria-hidden=true href=#quick-explanation-3>#</a></h3><p>Line 8 specifies the port of Prometheus server running locally
Line 11 specifies the port and DNS name of the metric endpoint created in Part 3. Note the dns is &ldquo;host.docker.internal&rdquo;, this worked for me when running containers with <a href=https://www.docker.com/products/docker-desktop>Docker Desktop</a>.</p><div class=Note style=background-color:var(--note);font-size:15px;margin-bottom:10px;margin-top:10px;padding:10px;border-radius:10px><i class="fas fa-exclamation-triangle"></i>
Note the Prometheus server configuration could be way more complicated than what we are doing here.Again the purpose of this blog is not to setup prometheus for production, we only what to tip our teo on the surface and have a feel on it!</div><p>Lets start Docker Desktop and run Prometheus server locally either using docker cmd or docker-compose at choice of yours.
When navigating to http://localhost:9090/targetsÔºåvoil√† ÔºÅBoth the Prometheus server and the Metric endpoints for the websocket are up and running !</p><p><img loading=lazy src=/posts/websocket-prometheus/prometheus1.png alt=prometheus1></p><p>As you can see both of the jobs that you specified in the prometheus.yml file are running !</p><p>When navigate back to the graph page, you can easily enter &ldquo;symbolPrice&rdquo; in the search box and hit execute. You then should be able to see a graph like the following and you can highlight different labels to see the price change for each of the symbols. In may case I selected &ldquo;BNBUSDT-high&rdquo;</p><p><img loading=lazy src=/posts/websocket-prometheus/prometheus2.png alt=prometheus2></p><p>Congratulations! You"v just reach the end of this blog, I know right ? It is a rather long blog to read, but at least I found the exercise pretty interesting and when you see the graph in Prometheus, it somewhat feeling really comforting !</p><p>Thanks for you patience, see you at my next blog !!</p></div><footer class=post-footer><ul class=post-tags><li><i class="fas fa-tags fa-sm"></i></li><li><a href=https://blacklabnz.github.io/tags/websocket/>websocket</a></li><li><a href=https://blacklabnz.github.io/tags/prometheus/>prometheus</a></li><li><a href=https://blacklabnz.github.io/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://blacklabnz.github.io/posts/databricks-secure/><span class=title>¬´ Prev Page</span><br><span>Secure Databricks cluster with vNet injection and access resources via Azure private endpoint</span></a></nav><div class=share-buttons><a>Share via:</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Consume Websocket stream and send to Prometheus in Python on twitter" href="https://twitter.com/intent/tweet/?text=Consume%20Websocket%20stream%20and%20send%20to%20Prometheus%20in%20Python&url=https%3a%2f%2fblacklabnz.github.io%2fposts%2fwebsocket-prometheus%2f&hashtags=websocket%2cprometheus%2cpython"><i class="fab fa-twitter fa-lg"></i></a>
<a target=_blank rel="noopener noreferrer" aria-label="share Consume Websocket stream and send to Prometheus in Python on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblacklabnz.github.io%2fposts%2fwebsocket-prometheus%2f&title=Consume%20Websocket%20stream%20and%20send%20to%20Prometheus%20in%20Python&summary=Consume%20Websocket%20stream%20and%20send%20to%20Prometheus%20in%20Python&source=https%3a%2f%2fblacklabnz.github.io%2fposts%2fwebsocket-prometheus%2f"><i class="fab fa-linkedin-in fa-lg"></i></a></div></footer><div id=page-comments></div><script>let currentTheme=document.getElementsByClassName("dark")[0],utterance=document.createElement("script");utterance.src="https://utteranc.es/client.js",utterance.setAttribute("repo","blacklabnz/blacklabnz.github.io"),utterance.setAttribute("issue-term","pathname"),utterance.setAttribute("crossorigin","anonymous"),utterance.setAttribute("async",''),currentTheme?utterance.setAttribute("theme","photon-dark"):utterance.setAttribute("theme","github-light"),document.querySelector("#page-comments").innerHTML='',document.querySelector("#page-comments").appendChild(utterance)</script><script src=/assets/js/utterance-theme.min.js></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://blacklabnz.github.io/>blacklabnz</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><i class="fas fa-chevron-circle-up fa-2x"></i></a>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>